<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | yangkun&#39;s blog</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/favicon.ico">
    <meta name="description" content="前端开发 yangkun的个人博客">
    <link rel="preload" href="/assets/css/0.styles.aa6d0e5c.css" as="style"><link rel="preload" href="/assets/js/app.99228dae.js" as="script"><link rel="preload" href="/assets/js/2.dc72d726.js" as="script"><link rel="preload" href="/assets/js/17.c71201a2.js" as="script"><link rel="prefetch" href="/assets/js/10.df67b612.js"><link rel="prefetch" href="/assets/js/11.f174a2f5.js"><link rel="prefetch" href="/assets/js/12.ded0bfe3.js"><link rel="prefetch" href="/assets/js/13.1371002c.js"><link rel="prefetch" href="/assets/js/14.bc56f233.js"><link rel="prefetch" href="/assets/js/15.33b49a9d.js"><link rel="prefetch" href="/assets/js/16.21268277.js"><link rel="prefetch" href="/assets/js/18.b2b86138.js"><link rel="prefetch" href="/assets/js/19.afab924c.js"><link rel="prefetch" href="/assets/js/20.f6869a3d.js"><link rel="prefetch" href="/assets/js/3.0bf6612a.js"><link rel="prefetch" href="/assets/js/4.4d64059e.js"><link rel="prefetch" href="/assets/js/5.cb5d5a29.js"><link rel="prefetch" href="/assets/js/6.965a4472.js"><link rel="prefetch" href="/assets/js/7.cfbda0a7.js"><link rel="prefetch" href="/assets/js/8.73fa1447.js"><link rel="prefetch" href="/assets/js/9.41ef645a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.aa6d0e5c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">yangkun's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link router-link-active">
  博客
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>React</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/react/手写React-hooks核心原理.html" class="active sidebar-link">手写React-hooks核心原理</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#usestate" class="sidebar-link">useState</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#useeffect" class="sidebar-link">useEffect</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#usememo" class="sidebar-link">useMemo</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#usecallback" class="sidebar-link">useCallback</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#memo" class="sidebar-link">memo</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#usecontext" class="sidebar-link">useContext</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#useref" class="sidebar-link">useRef</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#usereducer" class="sidebar-link">useReducer</a></li><li class="sidebar-sub-header"><a href="/blog/react/手写React-hooks核心原理.html#hook-使用规则" class="sidebar-link">hook 使用规则</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>前端工程化</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>TS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>linux服务器</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><code>react-hooks</code> 是 React 16.8 的新增特性。它可以让我们在函数组件中使用 state 、生命周期以及其他 react 特性，而不仅限于 class 组件。这篇文章通过手写 <code>react-hooks</code> 的核心原理来带大家轻松掌握 <code>react-hooks</code>，希望能够打动屏幕面前的你。</p> <h2 id="usestate"><a href="#usestate" class="header-anchor">#</a> useState</h2> <p><code>useState</code> 会返回一个数组：一个 state，一个更新 state 的函数。</p> <p><code>useState</code> 类似 class 组件的 this.setState，但是它<code>不会把新的 state 和旧的 state 进行合并，而是直接替换</code></p> <p>需要注意的是:</p> <p><code>useState 支持我们在调用的时候直接传入一个值，来指定 state 的默认值，比如这样 useState(0), useState({ a: 1 }), useState([ 1, 2 ])，还支持我们传入一个函数，来通过逻辑计算出默认值</code></p> <p><code>在state需要更新的时候也有两种方式 一个是通过一个新的 state 值更新，一个是通过函数式更新返回新的 state</code></p> <div class="language- extra-class"><pre class="language-text"><code>// 保存状态的数组
let hookStates = [];
// 索引
let hookIndex = 0;

function useState(initState) {

  //判断传入的参数是否是函数
  if (typeof initState === &quot;function&quot;) {
    hookStates[hookIndex] = initState();
  } else {
    hookStates[hookIndex] = hookStates[hookIndex] || initState;
  }

  // 使用闭包维护函数调用位置
  let currentIndex = hookIndex;
  function setState(newState) {
    // 判断传入的state是否为函数,如果是把prevState传入
    if (typeof newState === &quot;function&quot;) {
      // 重新复制给newState
      newState = newState(hookStates[currentIndex]);
    }

    // 更新state
    hookStates[currentIndex] = newState;

    // 触发视图更新的函数
    render();
  }

  // 返回数组形式
  return [hookStates[hookIndex++], setState];
}
</code></pre></div><h2 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> useEffect</h2> <p><code>useEffect</code> 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 <code>componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途</code>，只不过被合并成了一个 API。与 componentDidMount 或 componentDidUpdate 不同的是，<code>使用 useEffect 调度的 effect 不会阻塞浏览器更新视图</code>，这让你的应用看起来响应更快。</p> <p>需要注意的是<code>useEffect</code>中第二个参数的作用：</p> <ul><li><code>什么都不传，组件每次 render 之后 useEffect 都会调用</code></li> <li><code>传入一个空数组 [], useEffect 只会调用一次</code></li> <li><code>传入一个非空数组，其中包括变量，只有这些变量变动时，useEffect 才会执行</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>//保存状态的数组
let hookStates = [];

//索引
let hookIndex = 0;

function useEffect(callback, dependiencies) {
  if (hookStates[hookIndex]) {
    // 非初始调用

    let lastdependiencies = hookStates[hookIndex];

    // 判断传入依赖项跟上一次是否相同
    let same = dependiencies.every((item, i) =&gt; {
      //判断item是不是对象
      if (
        typeof item === &quot;object&quot; &amp;&amp;
        typeof item !== &quot;function&quot; &amp;&amp;
        item !== null
      ) {
        return isObjectValueEqual(item, lastdependiencies[i]);
      } else {
        return item === lastdependiencies[i];
      }
    });

    if (same) {
      hookIndex++;
    } else {
      hookStates[hookIndex++] = dependiencies;
      callback();
    }
  } else {
    // 初始调用

    hookStates[hookIndex++] = dependiencies;
    callback();
  }
}

//比较两个对象是否一致
function isObjectValueEqual(a, b) {
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);
  if (aProps.length != bProps.length) {
    return false;
  }
  for (var i = 0; i &lt; aProps.length; i++) {
    var propName = aProps[i];

    var propA = a[propName];
    var propB = b[propName];

    //b里面没有propName这个key名
    if (!b.hasOwnProperty(propName)) return false;

    // 判断两边都有相同键名
    if (propA instanceof Object) {
      if (this.isObjectValueEqual(propA, propB)) {
        // 这里不能return ,后面的对象还没判断
      } else {
        return false;
      }
    } else if (propA !== propB) {
      return false;
    } else {
    }
  }
  return true;
}

</code></pre></div><h2 id="usememo"><a href="#usememo" class="header-anchor">#</a> useMemo</h2> <p><code>useMemo</code> 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p> <p>需要注意的是<code>useMemo</code>中第二个参数的作用：</p> <ul><li><code>不传数组，每次更新都会重新计算</code></li> <li><code>空数组，只会计算一次</code></li> <li><code>依赖对应的值，当对应的值发生变化时，才会重新计算</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 保存状态的数组
let hookStates = [];
// 索引
let hookIndex = 0;

function useMemo(factory, dependencies) {
  if (hookStates[hookIndex]) {
    // 非首次调用
    let [lastMemo, lastDependencies] = hookStates[hookIndex];

   // 判断传入依赖项跟上一次是否相同
    let same = dependiencies.every((item, i) =&gt; {
      //判断item是不是对象
      if (
        typeof item === &quot;object&quot; &amp;&amp;
        typeof item !== &quot;function&quot; &amp;&amp;
        item !== null
      ) {
        return isObjectValueEqual(item, lastdependiencies[i]);
      } else {
        return item === lastdependiencies[i];
      }
    });

    if (same) {
      hookIndex++;
      return lastMemo;
    } else {
      // 只要有一个依赖变量不一样的话
      let newMemo = factory();
      hookStates[hookIndex++] = [newMemo, dependencies];
      return newMemo;
    }
  } else {
    // 首次调用
    let newMemo = factory();
    hookStates[hookIndex++] = [newMemo, dependencies];
    return newMemo;
  }
}

//比较两个对象是否一致
function isObjectValueEqual(a, b) {
    ...
}
</code></pre></div><h2 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> useCallback</h2> <p><code>useCallback</code> 接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新</p> <p><code>useCallback</code> 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p> <p>需要注意的是<code>useCallback</code>中第二个参数的作用：</p> <ul><li><code>不传数组，每次更新都会重新计算</code></li> <li><code>空数组，只会计算一次</code></li> <li><code>依赖对应的值，当对应的值发生变化时，才会重新计算</code></li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 保存状态的数组
let hookStates = [];
// 索引
let hookIndex = 0;

function useCallback(callback, dependencies) {
  if (hookStates[hookIndex]) {
    // 非首次
    let [lastCallback, lastDependencies] = hookStates[hookIndex];

   // 判断传入依赖项跟上一次是否相同
    let same = dependiencies.every((item, i) =&gt; {
      //判断item是不是对象
      if (
        typeof item === &quot;object&quot; &amp;&amp;
        typeof item !== &quot;function&quot; &amp;&amp;
        item !== null
      ) {
        return isObjectValueEqual(item, lastdependiencies[i]);
      } else {
        return item === lastdependiencies[i];
      }
    });

    if (same) {
      hookIndex++;
      return lastCallback;
    } else {
      // 只要有一个依赖变量不一样的话
      hookStates[hookIndex++] = [callback, dependencies];
      return callback;
    }
  } else {
    // 首次调用
    hookStates[hookIndex++] = [callback, dependencies];
    return callback;
  }
}

//比较两个对象是否一致
function isObjectValueEqual(a, b) {
    ...
}
</code></pre></div><h2 id="memo"><a href="#memo" class="header-anchor">#</a> memo</h2> <p><code>memo</code> 类似于 PureCompoent 作用是优化组件性能，防止组件触发重渲染, <code>memo</code>针对 一个组件的渲染是否重复执行</p> <div class="language- extra-class"><pre class="language-text"><code>function memo(OldFunComp) {
  return class extends React.PureComponent {
    render() {
      return &lt;OldFunComp {...this.props} /&gt;;
    }
  };
}
</code></pre></div><h2 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> useContext</h2> <p><code>useContext</code> 接收一个 context 对象（<code>React.createContext 的返回值</code>）并返回该 context 的当前值<code>useContext(MyContext)</code>, 只是让你能够读取 context 的值以及订阅 context 的变化。仍然需要在上层组件树中使用 <code>&lt;MyContext.Provider&gt;</code> 来为下层组件提供 context。</p> <div class="language- extra-class"><pre class="language-text"><code>function useContext(context) {
  return context._currentValue;
}

// 父组件
const CountCtx = React.createContext();
function ParentComp() {
  const [state, setState] = React.useState({ number: 0 });
  return (
    &lt;CountCtx.Provider value={{ state, setState }}&gt;
      &lt;Child /&gt;
    &lt;/CountCtx.Provider&gt;
  );
}

// 子组件
function Child() {
  let { state, setState } = useContext(CountCtx);
  return (
    &lt;div&gt;
      &lt;p&gt;{state.number}&lt;/p&gt;
      &lt;button onClick={() =&gt; setState({ number: state.number + 1 })}&gt;
        add
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><h2 id="useref"><a href="#useref" class="header-anchor">#</a> useRef</h2> <p><code>useRef</code> 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数
useRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的 ref 对象都是同一个（注意使用 React.createRef ，每次重新渲染组件都会重新创建 ref）</p> <div class="language- extra-class"><pre class="language-text"><code>let lastRef;

function useRef(value) {
  lastRef = lastRef || { current: value };
  return lastRef;
}
</code></pre></div><h2 id="usereducer"><a href="#usereducer" class="header-anchor">#</a> useReducer</h2> <p><code>useReducer</code> 接受类型为 (state, action) =&gt; newState 的 reducer，并返回与 dispatch 方法配对的当前状态。<code>useReducer</code> 和 redux 中 reducer 很像 useState 内部就是靠 useReducer 来实现的</p> <div class="language- extra-class"><pre class="language-text"><code>// 保存状态的数组
let hookStates = [];
// 索引
let hookIndex = 0;

function useReducer(reducer, initState) {
  hookStates[hookIndex] = hookStates[hookIndex] || initState;

  let currentIndex = hookIndex;
  function dispatch(action) {
    hookStates[currentIndex] = reducer
      ? reducer(hookStates[currentIndex], action)
      : action;
    // 触发视图更新
    render();
  }
  return [hookStates[hookIndex++], dispatch];
}

// useState可以使用useReducer改写
function useState(initState) {
  return useReducer(null, initState);
}
</code></pre></div><h2 id="hook-使用规则"><a href="#hook-使用规则" class="header-anchor">#</a> hook 使用规则</h2> <p>使用 Hooks 的时候必须遵守 2 条规则：</p> <ul><li><code>只能在代码的第一层调用 Hooks，不能在循环、条件分支或者嵌套函数中调用 Hooks。</code></li> <li><code>只能在Function Component或者自定义 Hook 中调用 Hooks，不能在普通的 JS 函数中调用。</code></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/js/EventLoop.html" class="prev">
        EventLoop
      </a></span> <span class="next"><a href="/blog/node/koa2+mysql环境搭建.html">
        koa2+mysql环境搭建
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.99228dae.js" defer></script><script src="/assets/js/2.dc72d726.js" defer></script><script src="/assets/js/17.c71201a2.js" defer></script>
  </body>
</html>
