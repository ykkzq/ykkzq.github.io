(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{330:function(v,_,s){"use strict";s.r(_);var t=s(33),p=Object(t.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("p",[v._v("一、重绘不一定需要重排，重排必然会导致重绘")]),v._v(" "),s("p",[v._v("1、重排：当我们改变一个元素的尺寸和位置时候，会重新进行样式计算、布局、绘制以及后面的所有流程，这种行为称为重排。")]),v._v(" "),s("p",[v._v("1）添加、删除可见的 dom")]),v._v(" "),s("p",[v._v("2）元素的位置改变")]),v._v(" "),s("p",[v._v("3）元素的尺寸改变（外边距、内边距、边框厚度、宽高等几何属性）")]),v._v(" "),s("p",[v._v("4）页面渲染初始化")]),v._v(" "),s("p",[v._v("5）浏览器窗口尺寸改变")]),v._v(" "),s("p",[v._v("2、重绘：当改变了某个元素的颜色属性时不会重新触发布局，但还是会触发样式的计算和绘制，这就是重绘。")]),v._v(" "),s("p",[v._v("二、减少重排、重绘")]),v._v(" "),s("p",[v._v("1、不要一条一条的修改 DOM 的样式，可以先定义好 css 的 class，然后修改 DOM 的 className。")]),v._v(" "),s("p",[v._v("2、不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。")]),v._v(" "),s("p",[v._v("3、为动画的 HTML 元件适用 fixed 或 absolute 的 position，那么修改他们的 css 是不会 reflow")]),v._v(" "),s("p",[v._v("三、我们可以发现重绘和重排都会占用主进程，还有 js 也会运行在这个主线程上，所以就会出现抢占执行时间的问题，如果你写了一个不断导致重排重绘的动画，浏览器则需要在每一帧都运行样式计算布局和绘制的操作。")])])}),[],!1,null,null,null);_.default=p.exports}}]);