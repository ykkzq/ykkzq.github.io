(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{330:function(e,t,r){"use strict";r.r(t);var a=r(33),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"何为迭代器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#何为迭代器"}},[e._v("#")]),e._v(" 何为迭代器")]),e._v(" "),r("p",[e._v("迭代器是被设计专用于迭代的对象，带有特定接口。所有的迭代器对象都拥有 next() 方 法，会返回一个结果对象。该结果对象有两个属性：对应下一个值的 value ，以及一个布尔 类型的  "),r("strong",[e._v("done")]),e._v(" ,其值为  "),r("strong",[e._v("true")]),e._v("  时表示没有更多值可供使用。迭代器持有一个指向集合位置的 内部指针，每当调用了 next() 方法，迭代器就会返回相应的下一个值。")]),e._v(" "),r("p",[e._v("在 ES5 中创建一个迭代器")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v('function createIterator(items) {\n    var i = 0;\n    return {\n        next: function () {\n            var done = i >= items.length;\n            var value = !done ? items[i++] : undefined\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\n\nvar iterator = createIterator([1, 2, 3]);\nconsole.log(iterator.next());\nconsole.log(iterator.next());\nconsole.log(iterator.next());\n\nconsole.log(iterator.next());  // "{ value: undefined, done: true }"\n')])])]),r("h1",{attrs:{id:"何为生成器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#何为生成器"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E4%BD%95%E4%B8%BA%E7%94%9F%E6%88%90%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("何为生成器")]),e._v(" "),r("p",[e._v("生成器 ("),r("strong",[e._v("generator")]),e._v(") 是能返回一个迭代器的函数。生成器函数由放在 function 关键字之 后的一个星号 (*) 来表示，并能使用新的  "),r("strong",[e._v("yield")]),e._v("  关键字。将星号紧跟在 function 关键 字之后，或是在中间留出空格，都是没问题的")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* createIterator() {\n    yield 1;\n    yield 2;\n    yield 3;\n}\n")])])]),r("p",[e._v("执行上面的打印依然可以")]),e._v(" "),r("p",[e._v("生成器函数最有意思的方面可能就是它们会在每个  "),r("strong",[e._v("yield")]),e._v("  语句后停止执行。此代码中 yield 1 执行后，该函数将不会再执行任何操作，直到迭代器的 next() 方法被调用，此时 才继续执行 yield 2")]),e._v(" "),r("p",[e._v("和表达式一起使用")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* createIterator(items) {\n    for (let i = 0; i < items.length; i++) {\n        yield items[i]\n    }\n}\n")])])]),r("h1",{attrs:{id:"生成器对象方法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成器对象方法"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("生成器对象方法")]),e._v(" "),r("p",[e._v("由于生成器就是函数，因此也可以被添加到对象中。例如，你可以在 ES5 风格的对象字面量 中使用函数表达式来创建一个生成器：")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("var o = {\n    createIterator: function* (items) {\n        for (let i = 0; i < items.length; i++) {\n            yield items[i]\n        }\n    }\n}\nlet iterator = o.createIterator([1, 2, 3]);\n")])])]),r("p",[e._v("用 ES6 简写")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("*createIterator(items){\n    //\n}\n")])])]),r("h1",{attrs:{id:"可迭代对象与-for-of-循环"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#可迭代对象与-for-of-循环"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1%E4%B8%8E-for-of-%E5%BE%AA%E7%8E%AF",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("可迭代对象与 for-of 循环")]),e._v(" "),r("p",[e._v("可迭代对象（ iterable ）是包含 Symbol.iterator 属性的对象")]),e._v(" "),r("p",[e._v("在 ES6 中，所有的集合 对象(数组、 Set 与 Map) 以及字符串都是可迭代对象，因此它们都被指定了默认的迭代 器。可迭代对象被设计用于与 ES 新增的 for-of 循环配合使用。")]),e._v(" "),r("ul",[r("li",[e._v("for-of 循环在循环每次执行时会调用可迭代对象的 next() 方法，并将结果对象的 value 值存储在一个变量上。循环过程会持续到结果对象的 done 属性变成 true 为止")])]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let values = [1, 2, 3]\nfor (const num of values) {\n    console.log(num)\n}\n// 1 2 3\n")])])]),r("ul",[r("li",[e._v("这个 for-of 循环首先调用了 values 数组的  "),r("strong",[e._v("Symbol.iterator")]),e._v("  方法，获取了一个迭代器")]),e._v(" "),r("li",[e._v("iterator.next() 被调用，迭 代器结果对象的 value 属性被读出并放入了 num 变量。 num 变量的值开始为 1 ，接下来 是 2 ，最后变成 3 。")]),e._v(" "),r("li",[e._v("当结果对象的 done 变成 true ，循环就退出了，因此 num 绝不会被 赋值为 undefined 。")])]),e._v(" "),r("h1",{attrs:{id:"访问默认迭代器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#访问默认迭代器"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E8%AE%BF%E9%97%AE%E9%BB%98%E8%AE%A4%E8%BF%AD%E4%BB%A3%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("访问默认迭代器")]),e._v(" "),r("p",[e._v("使用  "),r("strong",[e._v("Symbol.iterator")]),e._v("  来访问对象上的默认迭代器")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let values = [1, 2, 3]\nlet defIterator = values[Symbol.iterator]\n\nconsole.log(iterator.next());\n")])])]),r("h2",{attrs:{id:"检测对象是否能进行迭代"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#检测对象是否能进行迭代"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E6%A3%80%E6%B5%8B%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%90%A6%E8%83%BD%E8%BF%9B%E8%A1%8C%E8%BF%AD%E4%BB%A3",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("检测对象是否能进行迭代")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function isIterable(object) {\n    return typeof object[Symbol.iterator] === 'function'\n}\n\nconsole.log(isIterable([]));  //true\nconsole.log(isIterable(\"\"));  //true\nconsole.log(isIterable({}));  //false\nconsole.log(isIterable(1));   //false\nconsole.log(isIterable(new Map()));  //true\nconsole.log(isIterable(new Set()));  //true\nconsole.log(isIterable(new WeakMap()));  //false\nconsole.log(isIterable(new WeakSet()));  //false\n")])])]),r("h1",{attrs:{id:"创建可迭代对象"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建可迭代对象"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E5%88%9B%E5%BB%BA%E5%8F%AF%E8%BF%AD%E4%BB%A3%E5%AF%B9%E8%B1%A1",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("创建可迭代对象")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("let collection = {\n    obj: {},\n    *[Symbol.iterator]() {\n        for (const key in this.obj) {\n            yield this.obj[key]\n        }\n    }\n}\ncollection.obj.name = 'Tom'\ncollection.obj.age = 20\nfor (const iterator of collection) {\n    console.log(iterator);\n}\n")])])]),r("h1",{attrs:{id:"集合的迭代器"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#集合的迭代器"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E9%9B%86%E5%90%88%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("集合的迭代器")]),e._v(" "),r("p",[e._v("ES6 具有三种集合对象类型："),r("strong",[e._v("数组")]),e._v("、 "),r("strong",[e._v("Map")]),e._v("  与  "),r("strong",[e._v("Set")])]),e._v(" "),r("ul",[r("li",[e._v("entries():返回一个包含键值对的迭代器")]),e._v(" "),r("li",[e._v("values():返回一个包含集合中的值的迭代器")]),e._v(" "),r("li",[e._v("keys :返回一个包含集合中的键的迭代器")])]),e._v(" "),r("h1",{attrs:{id:"生成器的-return-语句"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#生成器的-return-语句"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E7%94%9F%E6%88%90%E5%99%A8%E7%9A%84-return-%E8%AF%AD%E5%8F%A5",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("生成器的 Return 语句")]),e._v(" "),r("p",[e._v("由于生成器是函数，你可以在它内部使用 return 语句，既可以让生成器早一点退出执行， 也可以指定在 next() 方法最后一次调用时的返回值。")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("function* createIterator() {\n    yield 1;\n    return;\n    yield 2\n    yield 3\n}\n\nlet iterator1 = createIterator();\nconsole.log(iterator1.next());  // { value: 1, done: false }\nconsole.log(iterator1.next());  // { value: undefined, done: true }\n")])])]),r("h1",{attrs:{id:"异步任务运行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#异步任务运行"}},[e._v("#")]),e._v(" "),r("a",{attrs:{href:"https://github.com/LiLixikun/webBlog/blob/master/JS/md/%E8%BF%AD%E4%BB%A3%E5%99%A8.md#%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C",target:"_blank",rel:"noopener noreferrer"}},[r("OutboundLink")],1),e._v("异步任务运行")]),e._v(" "),r("p",[e._v("对于异步代码，forEach 并不能保证按顺序执行。forEach 中用 await 会产生什么问题?怎么解决这个问题?")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("async function test() {\n\tlet arr = [4, 2, 1]\n\tarr.forEach(async item => {\n\t\tconst res = await handle(item)\n\t\tconsole.log(res)\n\t})\n\tconsole.log('结束')\n}\n\nfunction handle(x) {\n\treturn new Promise((resolve, reject) => {\n\t\tsetTimeout(() => {\n\t\t\tresolve(x)\n\t\t}, 1000 * x)\n\t})\n}\n\ntest()\n")])])]),r("p",[e._v("我们期望的结果是:")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("4 2 1 结束\n")])])]),r("p",[e._v("但是实际上会输出:")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("1 2 4 结束\n")])])]),r("p",[r("strong",[e._v("问题原因")])]),e._v(" "),r("p",[e._v("forEach 底层怎么实现的。")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("// 核心逻辑\nfor (var i = 0; i < length; i++) {\n  if (i in array) {\n    var element = array[i];\n    callback(element, i, array);\n  }\n}\n")])])]),r("p",[r("strong",[e._v("forEach")]),e._v("  拿过来直接执行了，这就导致它无法保证异步任务的执行顺序。比如后面的任务用时短，那么就又可能抢在前面的任务之前执行")]),e._v(" "),r("p",[r("strong",[e._v("解决方案")]),e._v("  其实也很简单, 我们利用  "),r("strong",[e._v("for...of")]),e._v("  就能轻松解决。")]),e._v(" "),r("div",{staticClass:"language-source-js extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[e._v("async function test() {\n  let arr = [4, 2, 1]\n  for(const item of arr) {\n\tconst res = await handle(item)\n\tconsole.log(res)\n  }\n\tconsole.log('结束')\n}\n")])])]),r("p",[e._v("解决原理——Iterator")]),e._v(" "),r("p",[e._v("for...of 并不像 forEach 那么简单粗暴的方式去遍历执行，而是采用一种特别的手段——迭代器去遍历。")])])}),[],!1,null,null,null);t.default=n.exports}}]);