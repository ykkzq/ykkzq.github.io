(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{337:function(e,t,n){"use strict";n.r(t);var a=n(33),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h2",{attrs:{id:"前言"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),n("p",[n("code",[e._v("react-hooks")]),e._v(" 是 React 16.8 的新增特性。它可以让我们在函数组件中使用 state 、生命周期以及其他 react 特性，而不仅限于 class 组件。这篇文章通过手写 "),n("code",[e._v("react-hooks")]),e._v(" 的核心原理来带大家轻松掌握 "),n("code",[e._v("react-hooks")]),e._v("，希望能够打动屏幕面前的你。")]),e._v(" "),n("h2",{attrs:{id:"usestate"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[e._v("#")]),e._v(" useState")]),e._v(" "),n("p",[n("code",[e._v("useState")]),e._v(" 会返回一个数组：一个 state，一个更新 state 的函数。")]),e._v(" "),n("p",[n("code",[e._v("useState")]),e._v(" 类似 class 组件的 this.setState，但是它"),n("code",[e._v("不会把新的 state 和旧的 state 进行合并，而是直接替换")])]),e._v(" "),n("p",[e._v("需要注意的是:")]),e._v(" "),n("p",[n("code",[e._v("useState 支持我们在调用的时候直接传入一个值，来指定 state 的默认值，比如这样 useState(0), useState({ a: 1 }), useState([ 1, 2 ])，还支持我们传入一个函数，来通过逻辑计算出默认值")])]),e._v(" "),n("p",[n("code",[e._v("在state需要更新的时候也有两种方式 一个是通过一个新的 state 值更新，一个是通过函数式更新返回新的 state")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useState(initState) {\n\n  //判断传入的参数是否是函数\n  if (typeof initState === "function") {\n    hookStates[hookIndex] = initState();\n  } else {\n    hookStates[hookIndex] = hookStates[hookIndex] || initState;\n  }\n\n  // 使用闭包维护函数调用位置\n  let currentIndex = hookIndex;\n  function setState(newState) {\n    // 判断传入的state是否为函数,如果是把prevState传入\n    if (typeof newState === "function") {\n      // 重新复制给newState\n      newState = newState(hookStates[currentIndex]);\n    }\n\n    // 更新state\n    hookStates[currentIndex] = newState;\n\n    // 触发视图更新的函数\n    render();\n  }\n\n  // 返回数组形式\n  return [hookStates[hookIndex++], setState];\n}\n')])])]),n("h2",{attrs:{id:"useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[e._v("#")]),e._v(" useEffect")]),e._v(" "),n("p",[n("code",[e._v("useEffect")]),e._v(" 就是一个 Effect Hook，给函数组件增加了操作副作用的能力。它跟 class 组件中的 "),n("code",[e._v("componentDidMount、componentDidUpdate 和 componentWillUnmount 具有相同的用途")]),e._v("，只不过被合并成了一个 API。与 componentDidMount 或 componentDidUpdate 不同的是，"),n("code",[e._v("使用 useEffect 调度的 effect 不会阻塞浏览器更新视图")]),e._v("，这让你的应用看起来响应更快。")]),e._v(" "),n("p",[e._v("需要注意的是"),n("code",[e._v("useEffect")]),e._v("中第二个参数的作用：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("什么都不传，组件每次 render 之后 useEffect 都会调用")])]),e._v(" "),n("li",[n("code",[e._v("传入一个空数组 [], useEffect 只会调用一次")])]),e._v(" "),n("li",[n("code",[e._v("传入一个非空数组，其中包括变量，只有这些变量变动时，useEffect 才会执行")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('//保存状态的数组\nlet hookStates = [];\n\n//索引\nlet hookIndex = 0;\n\nfunction useEffect(callback, dependiencies) {\n  if (hookStates[hookIndex]) {\n    // 非初始调用\n\n    let lastdependiencies = hookStates[hookIndex];\n\n    // 判断传入依赖项跟上一次是否相同\n    let same = dependiencies.every((item, i) => {\n      //判断item是不是对象\n      if (\n        typeof item === "object" &&\n        typeof item !== "function" &&\n        item !== null\n      ) {\n        return isObjectValueEqual(item, lastdependiencies[i]);\n      } else {\n        return item === lastdependiencies[i];\n      }\n    });\n\n    if (same) {\n      hookIndex++;\n    } else {\n      hookStates[hookIndex++] = dependiencies;\n      callback();\n    }\n  } else {\n    // 初始调用\n\n    hookStates[hookIndex++] = dependiencies;\n    callback();\n  }\n}\n\n//比较两个对象是否一致\nfunction isObjectValueEqual(a, b) {\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length != bProps.length) {\n    return false;\n  }\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n\n    var propA = a[propName];\n    var propB = b[propName];\n\n    //b里面没有propName这个key名\n    if (!b.hasOwnProperty(propName)) return false;\n\n    // 判断两边都有相同键名\n    if (propA instanceof Object) {\n      if (this.isObjectValueEqual(propA, propB)) {\n        // 这里不能return ,后面的对象还没判断\n      } else {\n        return false;\n      }\n    } else if (propA !== propB) {\n      return false;\n    } else {\n    }\n  }\n  return true;\n}\n\n')])])]),n("h2",{attrs:{id:"usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[e._v("#")]),e._v(" useMemo")]),e._v(" "),n("p",[n("code",[e._v("useMemo")]),e._v(" 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。")]),e._v(" "),n("p",[e._v("需要注意的是"),n("code",[e._v("useMemo")]),e._v("中第二个参数的作用：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("不传数组，每次更新都会重新计算")])]),e._v(" "),n("li",[n("code",[e._v("空数组，只会计算一次")])]),e._v(" "),n("li",[n("code",[e._v("依赖对应的值，当对应的值发生变化时，才会重新计算")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useMemo(factory, dependencies) {\n  if (hookStates[hookIndex]) {\n    // 非首次调用\n    let [lastMemo, lastDependencies] = hookStates[hookIndex];\n\n   // 判断传入依赖项跟上一次是否相同\n    let same = dependiencies.every((item, i) => {\n      //判断item是不是对象\n      if (\n        typeof item === "object" &&\n        typeof item !== "function" &&\n        item !== null\n      ) {\n        return isObjectValueEqual(item, lastdependiencies[i]);\n      } else {\n        return item === lastdependiencies[i];\n      }\n    });\n\n    if (same) {\n      hookIndex++;\n      return lastMemo;\n    } else {\n      // 只要有一个依赖变量不一样的话\n      let newMemo = factory();\n      hookStates[hookIndex++] = [newMemo, dependencies];\n      return newMemo;\n    }\n  } else {\n    // 首次调用\n    let newMemo = factory();\n    hookStates[hookIndex++] = [newMemo, dependencies];\n    return newMemo;\n  }\n}\n\n//比较两个对象是否一致\nfunction isObjectValueEqual(a, b) {\n    ...\n}\n')])])]),n("h2",{attrs:{id:"usecallback"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[e._v("#")]),e._v(" useCallback")]),e._v(" "),n("p",[n("code",[e._v("useCallback")]),e._v(" 接收一个内联回调函数参数和一个依赖项数组（子组件依赖父组件的状态，即子组件会使用到父组件的值） ，useCallback 会返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新")]),e._v(" "),n("p",[n("code",[e._v("useCallback")]),e._v(" 把创建函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。")]),e._v(" "),n("p",[e._v("需要注意的是"),n("code",[e._v("useCallback")]),e._v("中第二个参数的作用：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("不传数组，每次更新都会重新计算")])]),e._v(" "),n("li",[n("code",[e._v("空数组，只会计算一次")])]),e._v(" "),n("li",[n("code",[e._v("依赖对应的值，当对应的值发生变化时，才会重新计算")])])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useCallback(callback, dependencies) {\n  if (hookStates[hookIndex]) {\n    // 非首次\n    let [lastCallback, lastDependencies] = hookStates[hookIndex];\n\n   // 判断传入依赖项跟上一次是否相同\n    let same = dependiencies.every((item, i) => {\n      //判断item是不是对象\n      if (\n        typeof item === "object" &&\n        typeof item !== "function" &&\n        item !== null\n      ) {\n        return isObjectValueEqual(item, lastdependiencies[i]);\n      } else {\n        return item === lastdependiencies[i];\n      }\n    });\n\n    if (same) {\n      hookIndex++;\n      return lastCallback;\n    } else {\n      // 只要有一个依赖变量不一样的话\n      hookStates[hookIndex++] = [callback, dependencies];\n      return callback;\n    }\n  } else {\n    // 首次调用\n    hookStates[hookIndex++] = [callback, dependencies];\n    return callback;\n  }\n}\n\n//比较两个对象是否一致\nfunction isObjectValueEqual(a, b) {\n    ...\n}\n')])])]),n("h2",{attrs:{id:"memo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#memo"}},[e._v("#")]),e._v(" memo")]),e._v(" "),n("p",[n("code",[e._v("memo")]),e._v(" 类似于 PureCompoent 作用是优化组件性能，防止组件触发重渲染, "),n("code",[e._v("memo")]),e._v("针对 一个组件的渲染是否重复执行")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function memo(OldFunComp) {\n  return class extends React.PureComponent {\n    render() {\n      return <OldFunComp {...this.props} />;\n    }\n  };\n}\n")])])]),n("h2",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[e._v("#")]),e._v(" useContext")]),e._v(" "),n("p",[n("code",[e._v("useContext")]),e._v(" 接收一个 context 对象（"),n("code",[e._v("React.createContext 的返回值")]),e._v("）并返回该 context 的当前值"),n("code",[e._v("useContext(MyContext)")]),e._v(", 只是让你能够读取 context 的值以及订阅 context 的变化。仍然需要在上层组件树中使用 "),n("code",[e._v("<MyContext.Provider>")]),e._v(" 来为下层组件提供 context。")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("function useContext(context) {\n  return context._currentValue;\n}\n\n// 父组件\nconst CountCtx = React.createContext();\nfunction ParentComp() {\n  const [state, setState] = React.useState({ number: 0 });\n  return (\n    <CountCtx.Provider value={{ state, setState }}>\n      <Child />\n    </CountCtx.Provider>\n  );\n}\n\n// 子组件\nfunction Child() {\n  let { state, setState } = useContext(CountCtx);\n  return (\n    <div>\n      <p>{state.number}</p>\n      <button onClick={() => setState({ number: state.number + 1 })}>\n        add\n      </button>\n    </div>\n  );\n}\n")])])]),n("h2",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[e._v("#")]),e._v(" useRef")]),e._v(" "),n("p",[n("code",[e._v("useRef")]),e._v(" 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数\nuseRef 返回的 ref 对象在组件的整个生命周期内保持不变，也就是说每次重新渲染函数组件时，返回的 ref 对象都是同一个（注意使用 React.createRef ，每次重新渲染组件都会重新创建 ref）")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("let lastRef;\n\nfunction useRef(value) {\n  lastRef = lastRef || { current: value };\n  return lastRef;\n}\n")])])]),n("h2",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[e._v("#")]),e._v(" useReducer")]),e._v(" "),n("p",[n("code",[e._v("useReducer")]),e._v(" 接受类型为 (state, action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。"),n("code",[e._v("useReducer")]),e._v(" 和 redux 中 reducer 很像 useState 内部就是靠 useReducer 来实现的")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("// 保存状态的数组\nlet hookStates = [];\n// 索引\nlet hookIndex = 0;\n\nfunction useReducer(reducer, initState) {\n  hookStates[hookIndex] = hookStates[hookIndex] || initState;\n\n  let currentIndex = hookIndex;\n  function dispatch(action) {\n    hookStates[currentIndex] = reducer\n      ? reducer(hookStates[currentIndex], action)\n      : action;\n    // 触发视图更新\n    render();\n  }\n  return [hookStates[hookIndex++], dispatch];\n}\n\n// useState可以使用useReducer改写\nfunction useState(initState) {\n  return useReducer(null, initState);\n}\n")])])]),n("h2",{attrs:{id:"hook-使用规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hook-使用规则"}},[e._v("#")]),e._v(" hook 使用规则")]),e._v(" "),n("p",[e._v("使用 Hooks 的时候必须遵守 2 条规则：")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("只能在代码的第一层调用 Hooks，不能在循环、条件分支或者嵌套函数中调用 Hooks。")])]),e._v(" "),n("li",[n("code",[e._v("只能在Function Component或者自定义 Hook 中调用 Hooks，不能在普通的 JS 函数中调用。")])])])])}),[],!1,null,null,null);t.default=o.exports}}]);